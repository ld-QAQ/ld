## 1.lambda 表达式
* 能够使用Lambda的依据是必须有相应的函数接口（函数接口，是指内部只有一个抽象方法的接口）。  
这一点跟Java是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写Lambda表达式。  
实际上Lambda的类型就是对应函数接口的类型。Lambda表达式另一个依据是类型推断机制，在上下文信息足够的情况下，  
编译器可以推断出参数表的类型，而不需要显式指名。  
lambda表达式本身就是函数接口的实现  
* Lambda表达式有如下约定：  
一个 Lambda 表达式可以有零个或多个参数；  
参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同；  
所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c)；  
空圆括号代表参数集为空。例如：() -> 42；  
当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -> return a*a；  
Lambda 表达式的主体可包含零条或多条语句；  
如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致；  
如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空。  

* 举一个简单使用的例子,首先定义一个接口：  
```java
@FunctionalInterface
public interface DoSomethingInterface<T> {

    String doSomeThing(T t);
}
```
这个接口里面只能有一个函数，接口里是返回值为String类型的方法，那么下面使用它的时候就需要有返回值：

```java
 class MainTest{

     public static void main(String[] args) {

         DoSomethingInterface<String> t = str -> {
             return str;
         };
         String print = t.doSomeThing("print");
         System.out.println(print);

     }
}
```
t就相当于是接口的具体实现，那么使用 t.doSomeThing("print")就会去调用 t 的匿名函数执行。从这段代码看,如果我们有一个抽象类的具体实现逻辑相对简单不用大段代码的时候，可以使用 Lambda 表达式去实现具体的逻辑，这样就不用new 多个类。


## 2.java浅拷贝与深拷贝
2.1浅拷贝  
浅拷贝是按位拷贝对象,这个过程会创建一个新的对象,这个对象拥有着原有对象的一份精确地拷贝.
如果属性是基本类型，那么拷贝的就是基本数据类型的值；如果属性是引用类型（内存地址）,那么拷贝的就是内存地址,对此,也就是说只要其中某一个对象改变了这个地址,就会影响到另一个对象

2.2深拷贝  
深拷贝会拷贝所有的属性,并拷贝属性指向动态分配的内存地址
当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。

2.3实现  
2.3.1重写clone（）的实现  
浅拷贝  
```java
public class CopyDemo{
	
	public static void main(String[] args){
		
		Teacher teacher = new Teacher();
		
		teacher.setName("Tom");
		
		teacher.setAge(25);
		
		Student student1 = new Student();
		
		student1.setTeacher(teacher);
		
		student1.setName("Bob");
		
		student1.setAge(18);
		
		Student student2 = (Student)student1.clone();
		
		System.out.println("have cloned");
		
		System.out.println(student1);
		
		System.out.println(student2);
		
		System.out.println("changed");
		
		student1.setAge(17);
		
		student1.getTeacher().setAge(26);
		
		System.out.println(student1);
		
		System.out.println(student2);
		
	}
}
class Teacher implements Cloneable{
	
	private String name;
	
	private int age;
	
	public String getName(){
		return name;
	}
	
	public void setName(String name){
		this.name = name;
	}
	
	public int getAge(){
		return age;
	}
	
	public void setAge(int age){
		this.age = age;
	}
	
	public String toString(){
		return "[teacherName = " +this.name + " teacherAge = "+ this.age+"]";
	}
}
class Student implements Cloneable{
	
	private Teacher teacher;
	
	private String name;
	
	private int age;
	
	public Teacher getTeacher(){
		return teacher;
	}
	
	public void setTeacher(Teacher teacher){
		this.teacher = teacher;
	}
	
	public String getName(){
		return name;
	}
	
	public void setName(String name){
		this.name = name;
	}
	
	public int getAge(){
		return age;
	}
	
	public void setAge(int age){
		this.age = age;
	}
	
	public String toString(){
		return "[studentName = "+this.name + " studentAge = "+ this.age+" teacher = "+ this.teacher +"]";
	}
	
	public Object clone(){
		try{
			return super.clone();
		}catch(CloneNotSupportedException e){
			return null;
		}
	}
}
```
深拷贝

```java
public class CopyDemo1{
	
	public static void main(String[] args){
		
		Teacher teacher = new Teacher();
		
		teacher.setName("Tom");
		
		teacher.setAge(25);
		
		Student student1 = new Student();
		
		student1.setTeacher(teacher);
		
		student1.setName("Bob");
		
		student1.setAge(18);
		
		Student student2 = (Student)student1.clone();
		
		System.out.println("have cloned");
		
		System.out.println(student1);
		
		System.out.println(student2);
		
		System.out.println("changed");
		
		student1.setAge(17);
		
		student1.getTeacher().setAge(26);
		
		System.out.println(student1);
		
		System.out.println(student2);
		
	}
}
class Teacher implements Cloneable{
	
	private String name;
	
	private int age;
	
	public String getName(){
		return name;
	}
	
	public void setName(String name){
		this.name = name;
	}
	
	public int getAge(){
		return age;
	}
	
	public void setAge(int age){
		this.age = age;
	}
	
	public Object clone(){
		try{
			return super.clone();
		}catch(CloneNotSupportedException e){
			return null;
		}
	}
	
	public String toString(){
		return "[teacherName = " +this.name + " teacherAge = "+ this.age+"]";
	}
}
class Student implements Cloneable{
	
	private Teacher teacher;
	
	private String name;
	
	private int age;
	
	public Teacher getTeacher(){
		return teacher;
	}
	
	public void setTeacher(Teacher teacher){
		this.teacher = teacher;
	}
	
	public String getName(){
		return name;
	}
	
	public void setName(String name){
		this.name = name;
	}
	
	public int getAge(){
		return age;
	}
	
	public void setAge(int age){
		this.age = age;
	}
	
	public String toString(){
		return "[studentName = "+this.name + " studentAge = "+ this.age+" teacher = "+ this.teacher +"]";
	}
	
	public Object clone(){
		Student student = null;
		try{
			student = (Student) super.clone();
		}catch(CloneNotSupportedException e){
			return null;
		}
		student.setTeacher((Teacher)student.getTeacher().clone());
		return student;
	}
}
```
2.3.2不依赖重写clone()的实现  
浅拷贝  
拷贝构造函数来实现  
```java
public class CopyDemo4 {
    public static void main(String[] args) {
        Age age = new Age(26);
        Student student = new Student("Bob",age);
        //通过构造函数进行浅拷贝
        Student cloneStudent = new Student(student);
        System.out.println(student);
        System.out.println(cloneStudent);

        //修改属性并查看变化
        student.setName("Tom");//原对象改变，拷贝对象不变
        //age.setAge(20);两对象均改变   这个操作是直接修改Age类的属性
        student.setAge(new Age(20));//原对象改变，拷贝对象不变  这个操作new一个Age对象对Student的属性进行修改

        System.out.println(student);
        System.out.println(cloneStudent);

    }
}
/*
 * 创建年龄类
 * */
class Age{
    private int age;
    //构造方法
    public Age(int age){
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Age{" +
                "age=" + age +
                '}';
    }
}
/*
* 创建学生类
* */
class Student{
    private String name;
    private Age age;

    public Student(String name, Age age) {
        this.name = name;
        this.age = age;
    }
    //拷贝构造函数


    public Student(Student student) {
        this.name = student.name;
        this.age = student.age;
    }

    public String getName() {
        return name;
    }

    public Age getAge() {
        return age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(Age age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

}
```
深拷贝  
采用序列化的方式进行深拷贝  
```java
package com.liudong.Demo;

import com.sun.xml.internal.messaging.saaj.util.ByteInputStream;

import java.io.*;

public class DeepCopyBySerialization {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Age age = new Age(26);
        Student student = new Student("Bob",age);
        //通过序列化实现深拷贝
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(student);
        oos.flush();
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        Student cloneStudent = (Student)ois.readObject();
        System.out.println(student);
        System.out.println(cloneStudent);

        //修改属性并查看变化
        student.setName("Tom");//原对象改变，拷贝对象不变
        //age.setAge(20);两对象均改变   这个操作是直接修改Age类的属性
        student.setAge(new Age(20));//原对象改变，拷贝对象不变  这个操作new一个Age对象对Student的属性进行修改

        System.out.println(student);
        System.out.println(cloneStudent);

    }
}

/*
 * 创建年龄类
 * */
class Age implements  Serializable{
    private int age;
    //构造方法
    public Age(int age){
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Age{" +
                "age=" + age +
                '}';
    }
}
/*
 * 创建学生类
 * */
class Student implements Serializable{
    private String name;
    private Age age;

    public Student(String name, Age age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public Age getAge() {
        return age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(Age age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

}
```

### 3.接口与抽象类
抽象类可以没有抽象方法，但是如果你的一个类已经声明成了抽象类，  
即使这个类中没有抽象方法，它也不能再实例化，即不能直接构造一个该类的对象。  
如果一个类中有了一个抽象方法，那么这个类必须声明为抽象类，否则编译通不过。  

在接口中 不可以有构造方法  
在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors。  
A. 构造方法用于初始化成员变量，但是接口成员变量是常量,无需修改。接口是一种规范，  
被调用时，主要关注的是里边的方法，而方法是不需要初始化的，  
B. 类可以实现多个接口，若多个接口都有自己的构造器，则不好决定构造器链的调用次序  
C. 构造器是属于类自己的，不能继承。因为是纯虚的，接口不需要构造器。  

在抽象类中 可以有构造方法。但是应该声明为“protected”  
在抽象类中可以有构造方法，只是不能直接创建抽象类的实例对象，  
但实例化子类的时候，就会初始化父类，不管父类是不是抽象类都会调用父类的构造方法，  
初始化一个类，先初始化父类。   
作用：1.初始化抽象类的成员2.为继承自它的子类使用。  

1）接口不能有构造方法，抽象类可以有。  
2）接口不能有方法体，抽象类可以有。  
3）接口不能有静态方法，抽象类可以有。  
4）在接口中凡是变量必须是public static final，而在抽象类中没有要求。  

抽象类中不一定有抽象方法，抽象方法一定存在于抽象类中。  
继承抽象类的可以是普通类，但必须重写抽象类中的所有抽象方法，也可以是抽象类，无需重写抽象类中的所有抽象方法。  

```java
abstract class Shape{
	public abstract double getArea();
	public abstract double getPermiter();
}

class Circle extends Shape{
	double r;
	public Circle(double r){
		this.r = r;
	}
	public double getArea(){
		return Math.PI*this.r*this.r;
	}
	public double getPermiter(){
		return Math.PI*this.r*2;
	}
}

public class Demo1{
	public static void main(String[] args){
		Circle c = new Circle(5);
		System.out.println(c.getArea());
		System.out.println(c.getPermiter());
	}
}
```




